#
# This script is meant to be sourced in shell config file e.g. ".bashrc" in bash.
#
# Kubech is a simple tool that lets you set contexts/namespaces per shell/terminal.
# That's help you to manage multi Kubernetes cluster at the same time.


#
# Vars.
KUBECONFIG_ORIG="${KUBECONFIG:-$HOME/.kube/config}"
KUBECONFIG_SRC_DIR="${KUBECONFIG_SRC_DIR:-$HOME/.kube/config.src.d}"
KUBECONFIG_DEST_DIR="${KUBECONFIG_DEST_DIR:-$HOME/.kube/config.dest.d}"
KUBECONFIG_ACTIVE=""
KUBECH_NAMESPACE_CHECK="${KUBECH_NAMESPACE_CHECK:-list}"


#
# Usage.
kubech () {
  cat <<EOF
NOTE:
  - The command "kubech" is just a meta for other commands. So kubech does nothing by itself.
  - Also short names like "kchc/kchn/kchu" are available.

VARS:
  KUBECONFIG_SRC_DIR     : Set directory with extra kubectl config files to read in kubech commands.
                           This allow to have multiple config files in addition to
                           the one at "\$HOME/.kube/config".
                           Default: "${KUBECONFIG_SRC_DIR}"
  KUBECONFIG_DEST_DIR    : Set directory for temporary kubectl config files. The files
                           in this directory are auto-generated by kubech commands
                           and you don't need to interact with them or even change that var.
                           Default: "${KUBECONFIG_DEST_DIR}"
  KUBECH_NAMESPACE_CHECK : Method used to check if namespace exists before switching to it.
                           The default lists all namespaces which can be slow in large
                           clusters. After kubernetes 1.22+ all namespaces have a label
                           that can be used to speed this up. Set to "label" to enable this.
                           Available options: "list", "label".
                           Default: "${KUBECH_NAMESPACE_CHECK}"

USAGE:
  kubechc             : List all contexts
  kubechc <CONTEXT>   : Switch to context <CONTEXT>
  kubechn             : List all namespaces
  kubechn <NAMESPACE> : Switch to namespace <NAMESPACE>
  kubechu             : Unset the active context. This is just a safty net
                        to avoid applying config by mistake to the wrong cluster.
  kubechr             : Remove auto-generated kubeconf files from kubech dist dir.
  kubechz             : Zeroing/resetting the KUBECONFIG env var.
EOF
}


#
# General.

# Create config dirs.
mkdir -p "${KUBECONFIG_SRC_DIR}" "${KUBECONFIG_DEST_DIR}"
chmod 744 "${KUBECONFIG_SRC_DIR}" "${KUBECONFIG_DEST_DIR}"

_kube_print_list() {
    IFS=$'\n\t'

    local yellow darkbg normal
    yellow=$(tput setaf 3 || true)
    darkbg=$(tput setab 0 || true)
    normal=$(tput sgr0 || true)

    local cur_item_fg cur_item_bg
    cur_item_fg=${KUBECTX_CURRENT_FGCOLOR:-$yellow}
    cur_item_bg=${KUBECTX_CURRENT_BGCOLOR:-$darkbg}

    local item items_list

    cur_item=${1}
    if [ -n "$ZSH_VERSION" ]; then
        eval "items_list=(${2})"
    else
        items_list=${2}
    fi

    for item in $items_list; do
        if [[ -n "${_KUBECTX_FORCE_COLOR:-}" || \
            -t 1 && -z "${NO_COLOR:-}" ]]; then
            # colored output mode
            if [[ "${item}" = "${cur_item}" ]]; then
                echo "${cur_item_bg}${cur_item_fg}${item}${normal}"
            else
                echo "${item}"
            fi
        else
            echo "${item}"
        fi
    done
}

_kube_current_context() {
    kubectl config view -o=jsonpath='{.current-context}'
}

_kube_get_contexts() {
    #kubectl config get-contexts --kubeconfig=${kube_config_file_org} -o=name | sort -n
    KUBECONFIG=$(_kube_config) kubectl config get-contexts --no-headers=true -o name
}

_kube_list_contexts() {
    local cur_ctx kube_contexts_all
    cur_ctx="$(_kube_current_context)" || exit_err "error getting current context"
    kube_contexts_all=$(_kube_get_contexts) || exit_err "error getting context list"
    _kube_print_list ${cur_ctx} ${kube_contexts_all}
}

_kube_current_namespace() {
    local cur_ctx

    cur_ctx="$(_kube_current_context)" || exit_err "error getting current context"
    ns="$(kubectl config view -o=jsonpath="{.contexts[?(@.name==\"${cur_ctx}\")].context.namespace}")" \
        || exit_err "error getting current namespace"

    if [[ -z "${ns}" ]]; then
        echo "default"
    else
        echo "${ns}"
    fi
}

_kube_get_namespaces() {
    kubectl get namespaces -o=jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}'
    #kubectl get namespaces -o=jsonpath='{range .items[*].metadata.name}{@}{"\n"}{end}'
}

_kube_list_namespaces() {
    local cur_ns kube_namespace_all
    cur_ns="$(_kube_current_namespace)" || exit_err "error getting current namespace"
    kube_namespace_all=$(_kube_get_namespaces) || exit_err "error getting namespace list"
    _kube_print_list ${cur_ns} ${kube_namespace_all}
}

#
# Handeling Kube config files.
_kubeconfig_files () {
    if [ -d "${KUBECONFIG_SRC_DIR}" ]; then
        KUBECONFIG_FILES="$(find "${KUBECONFIG_SRC_DIR}" -type f -print | tr '\n' ':')"
    fi
    echo "${KUBECONFIG_FILES}${KUBECONFIG_ORIG}"
}

_kube_config () {
    KUBECONFIG_DEFAULT="$(_kubeconfig_files)"
    if [ -n "${1}" ]; then
        if [[ "${KUBECONFIG}" == "${KUBECONFIG_ACTIVE}" ]]; then
            export KUBECONFIG="${1}:${KUBECONFIG_DEFAULT}"
        else
            export KUBECONFIG="${1}:${KUBECONFIG}:${KUBECONFIG_DEFAULT}"
        fi
        KUBECONFIG_ACTIVE="${KUBECONFIG}"

    elif [ -n "${KUBECONFIG}" ]; then
        KUBECONFIG_ACTIVE="${KUBECONFIG}:${KUBECONFIG_DEFAULT}"
        echo "${KUBECONFIG_ACTIVE}"

    else
        KUBECONFIG_ACTIVE="${KUBECONFIG_DEFAULT}:${KUBECONFIG_ORIG}"
        echo "${KUBECONFIG_ACTIVE}"
    fi
}

#
# Remove non-alphanumeric characters in kubeconfig filename for certain kube context.
_kube_context_filename () {
  kube_context="${1}"
  kube_namespace="${2}"
  kube_context_filename=$(echo "${kube_context}" | tr -c '[:alnum:]\n' '_')

  echo "${kube_context_filename}-${kube_namespace}.yaml"
}

#
# Generate kubectl config for a single context.
_kubechg () {
    kube_context="${1}"
    kube_namespace="${2:-default}"
    kubeconfig_file="$(_kube_context_filename "${kube_context}" "${kube_namespace}")"

    touch "${KUBECONFIG_DEST_DIR}/${kubeconfig_file}"
    chmod 600 "${KUBECONFIG_DEST_DIR}/${kubeconfig_file}"

    KUBECONFIG="$(_kube_config)"    \
    kubectl config view             \
        --minify                    \
        --flatten                   \
        --context="${kube_context}" > \
        "${KUBECONFIG_DEST_DIR}/${kubeconfig_file}"
}

#
# Change kubectl context.
kubechc () {
    kube_context="${1}"
    kube_namespace="${2:-default}"

    if [[ -n "${kube_context}" ]]; then
        _kubechg "${kube_context}" "${kube_namespace}"
        _kube_config "${KUBECONFIG_DEST_DIR}/$(_kube_context_filename "${kube_context}" "${kube_namespace}")"
        # kubectl config current-context
        kubectl config set-context --current --namespace="${kube_namespace}"
        echo "Switched to namespace \"${kube_namespace}\""
    else
        #KUBECONFIG=$(_kube_config) kubectl config get-contexts --no-headers=true -o name
        _kube_list_contexts
    fi
}

#
# Change kubectl namespace
kubechn () {
    if [[ -n ${1} ]]; then
        kube_namespace="${1}"

        if [[ "${KUBECH_NAMESPACE_CHECK}" == "label" ]]; then
            kube_namespace_exists=$(kubectl get namespaces -l "kubernetes.io/metadata.name=${kube_namespace}" -o name)
        else
            kube_namespace_all=$(_kube_get_namespaces)
            kube_namespace_exists=$(echo "${kube_namespace_all}" | grep -E "^${kube_namespace}$")
        fi

        # Only switch namespace if it exists.
        if [[ -n "${kube_namespace_exists}" ]]; then
            kubechc "$(_kube_current_context)" "${kube_namespace}"
        else
            echo "The namespace \"${kube_namespace}\" doesn't exist"
        fi
    else
        _kube_list_namespaces
    fi
}

#
# Unset the active context.
kubechu () {
    kubectl config unset current-context
}

#
# Remove auto-generated kubeconf files from kubech dist dir.
kubechr () {
    ls "${KUBECONFIG_DEST_DIR}"/*.yaml &&
    rm "${KUBECONFIG_DEST_DIR}"/*.yaml
}

alias kchc='kubechc'
alias kchn='kubechn'
alias kchu='kubechu'
alias kchr='kubechr'

#
# Zeroing/resetting the KUBECONFIG env var.
kubechz () {
    export KUBECONFIG="${KUBECONFIG_ORIG}"
}

alias kchr='kubechz'
